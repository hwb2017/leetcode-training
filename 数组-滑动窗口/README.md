# 滑动窗口算法
滑动窗口算法主要是通过构造一个窗口大小可变的滑动窗口(由左右两边的指针来限制范围),当窗口中的字符串还一定不能满足条件时，则右指针向右拓展1位并进行些计算，当右指针满足一定条件后，在右移左指针来看缩小后的窗口还能不能满足条件。

由于大部分计算结果都被窗口的主体“缓存”起来了，减少了大量重复计算，所以可以减少一定的时间复杂度

滑动窗口中的循环跳出条件一般是左指针到达了数组的右边界

# 找到字符串中的所有异位字符串-438
`题目描述:` 给定一个字符串 s 和一个非空字符串 p，找到 s 中所有是 p 的字母异位词的子串，返回这些子串的起始索引。

字符串只包含小写英文字母，并且字符串 s 和 p 的长度都不超过 20100。

说明：

字母异位词指字母相同，但排列不同的字符串。
不考虑答案输出的顺序。

`题解:` 这里构成异位词关系的字符串有点类似加法交换律和乘法交换律的关系，即不论数字(题目中则是字符)的顺序怎么变，它们的和/积是不变的，所以一开始在想能不能通过将字符串转为一个数字和的形式来解答，难点在于如何保证一个数字和只能对应一个字符集合(无序),不能由多个字符集合对应同一个数字和。这里没有想到简单高效的方法，看了最后的题解也没有类似的解题方法。

所以后来的解决方法是通过一个Map来保存窗口中所有字符的出现频数，当窗口值还小于 p.length 时，就扩大窗口，当窗口等于 p.length 后，在通过这个 Map 来判断窗口中的字符串是否为 p 的异位词，即所有的键和值都一样，如果不是异位词，则在Map中减小左指针i所指向元素的频数，如果减到0则移出Map，然后左指针i左移

看了更优的解答，基本都把字符转为ASCII值来处理了

# 最小覆盖字串-76
`题目描述:` 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

注意：如果 s 中存在这样的子串，我们保证它是唯一的答案。

`题解:` 这里直接借鉴 ssh 的 javascript [题解](https://github.com/sl1673495/leetcode-javascript/blob/master/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.js)，还可以优化的部分应该频次是否和目标字符串匹配的判断时机，ssh的题解中是每次循环中都判断，应该可以延迟到当 s[right] 比目标字符串中对应的字符的频次还高的时候，这时候再对之前已经遍历过的字符字串进行处理并确定合适的左指针右移距离，即要保证尽可能右移得多点，又要不遗漏后续的其他可能